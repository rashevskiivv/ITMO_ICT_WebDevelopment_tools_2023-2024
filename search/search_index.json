{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Practice Check out practice commit or practice1 folder. Other in lab section.","title":"Practice"},{"location":"#practice","text":"Check out practice commit or practice1 folder. Other in lab section.","title":"Practice"},{"location":"lab/","text":"Lab Structure Code models from datetime import datetime from enum import Enum from typing import Optional, List from sqlmodel import SQLModel, Field, Relationship class CategoryEnum(Enum): salary = 'salary' home = 'home' health = 'health' sports = 'sports' food = 'food' technology = 'technology' cashback = 'cashback' gifts = 'gifts' other = 'other' class OperationEnum(Enum): income = 'income' # revenue outcome = 'outcome' # expense class CategoryOperationLink(SQLModel, table=True): # many-many id: Optional[int] = Field(default=None, primary_key=True, unique=True) category_id: Optional[int] = Field( default=None, foreign_key=\"category.id\", primary_key=True ) operation_id: Optional[int] = Field( default=None, foreign_key=\"operation.id\", primary_key=True ) amount: Optional[float] = Field(default=None) class Category(SQLModel, table=True): id: Optional[int] = Field(default=None, primary_key=True) category: CategoryEnum = Field(unique=True) limit: float = Field(default=0.0) current: float = Field(default=0.0) operations: Optional[List[\"Operation\"]] = Relationship(back_populates=\"categories\", link_model=CategoryOperationLink) # many-many favourite_category: List[\"Customer\"] = Relationship(back_populates=\"favourite_category\") # 1-many # * class Operation(SQLModel, table=True): id: Optional[int] = Field(default=None, primary_key=True) operation: OperationEnum = Field(unique=True) limit: float = Field(default=0.0) alias: Optional[str] = Field(default=None, nullable=True) categories: Optional[List[Category]] = Relationship(back_populates=\"operations\", link_model=CategoryOperationLink) # many-many class User(SQLModel): username: str = Field(unique=True, index=True, nullable=False) password: str = Field(nullable=False) favourite_category_id: Optional[int] = Field(default=None, foreign_key=\"category.id\") # 1-many class Customer(User, table=True): id: Optional[int] = Field(default=None, primary_key=True) balance: float = Field(default=0.0, nullable=False) favourite_category: Optional[Category] = Relationship(back_populates=\"favourite_category\") # 1-many # * class CustomerCategory(User): favourite_category: Optional[Category] = None # * class Transaction(SQLModel, table=True): id: Optional[int] = Field(default=None, primary_key=True) date: datetime = Field(default=None, nullable=False) amount: float = Field(default=None, nullable=False) customer_id: Optional[int] = Field(default=None, foreign_key=\"customer.id\") # 1-many category_operation_link_id: Optional[int] = Field(default=None, foreign_key=\"categoryoperationlink.id\") # 1-many Customer handler (other are similar) from typing import List from fastapi import APIRouter, Depends from db import get_session from models import Customer, CustomerCategory customerRouter = APIRouter(prefix=\"/customers\", tags=[\"customer\"]) # \u043e\u0442\u0432\u0435\u0447\u0430\u0435\u0442 \u0437\u0430 swagger @customerRouter.get(\"/\", response_model=list[CustomerCategory]) async def get_customers(session=Depends(get_session)) -> List[Customer]: customers = session.query(Customer).all() return customers @customerRouter.get(\"/{username_id}\", response_model=CustomerCategory) async def get_customer(username_id: int, session=Depends(get_session)) -> Customer: customer = session.get(Customer, username_id) return customer @customerRouter.post(\"/\") async def create_customer(customer: Customer, session=Depends(get_session)): customer = Customer.validate(customer) customer.id = None session.add(customer) session.commit() session.refresh(customer) return customer @customerRouter.patch(\"/{username}\") async def update_customer(customer: Customer, username: str, session=Depends(get_session)): customer = Customer.validate(customer) customer_from_db = session.query(Customer).filter(Customer.username == username).first() if customer_from_db is None: return \"No such customer\" customer_data = customer.model_dump(exclude_unset=True) for key, value in customer_data.items(): if value is None: continue setattr(customer_from_db, key, value) session.add(customer_from_db) session.commit() session.refresh(customer_from_db) return customer_from_db @customerRouter.delete(\"/{username}\") async def delete_customer(username: str, session=Depends(get_session)): session.query(Customer).filter(Customer.username == username).delete() session.commit() return \"Deleted\" DB from sqlmodel import SQLModel, Session, create_engine from dotenv import load_dotenv import os load_dotenv('.env') db_url = os.getenv('DB_URL') print(db_url) engine = create_engine(db_url, echo=True) def init_db(): SQLModel.metadata.create_all(engine) def get_session(): with Session(engine) as session: yield session Screenshots Swagger","title":"Lab"},{"location":"lab/#lab","text":"","title":"Lab"},{"location":"lab/#structure","text":"","title":"Structure"},{"location":"lab/#code","text":"","title":"Code"},{"location":"lab/#models","text":"from datetime import datetime from enum import Enum from typing import Optional, List from sqlmodel import SQLModel, Field, Relationship class CategoryEnum(Enum): salary = 'salary' home = 'home' health = 'health' sports = 'sports' food = 'food' technology = 'technology' cashback = 'cashback' gifts = 'gifts' other = 'other' class OperationEnum(Enum): income = 'income' # revenue outcome = 'outcome' # expense class CategoryOperationLink(SQLModel, table=True): # many-many id: Optional[int] = Field(default=None, primary_key=True, unique=True) category_id: Optional[int] = Field( default=None, foreign_key=\"category.id\", primary_key=True ) operation_id: Optional[int] = Field( default=None, foreign_key=\"operation.id\", primary_key=True ) amount: Optional[float] = Field(default=None) class Category(SQLModel, table=True): id: Optional[int] = Field(default=None, primary_key=True) category: CategoryEnum = Field(unique=True) limit: float = Field(default=0.0) current: float = Field(default=0.0) operations: Optional[List[\"Operation\"]] = Relationship(back_populates=\"categories\", link_model=CategoryOperationLink) # many-many favourite_category: List[\"Customer\"] = Relationship(back_populates=\"favourite_category\") # 1-many # * class Operation(SQLModel, table=True): id: Optional[int] = Field(default=None, primary_key=True) operation: OperationEnum = Field(unique=True) limit: float = Field(default=0.0) alias: Optional[str] = Field(default=None, nullable=True) categories: Optional[List[Category]] = Relationship(back_populates=\"operations\", link_model=CategoryOperationLink) # many-many class User(SQLModel): username: str = Field(unique=True, index=True, nullable=False) password: str = Field(nullable=False) favourite_category_id: Optional[int] = Field(default=None, foreign_key=\"category.id\") # 1-many class Customer(User, table=True): id: Optional[int] = Field(default=None, primary_key=True) balance: float = Field(default=0.0, nullable=False) favourite_category: Optional[Category] = Relationship(back_populates=\"favourite_category\") # 1-many # * class CustomerCategory(User): favourite_category: Optional[Category] = None # * class Transaction(SQLModel, table=True): id: Optional[int] = Field(default=None, primary_key=True) date: datetime = Field(default=None, nullable=False) amount: float = Field(default=None, nullable=False) customer_id: Optional[int] = Field(default=None, foreign_key=\"customer.id\") # 1-many category_operation_link_id: Optional[int] = Field(default=None, foreign_key=\"categoryoperationlink.id\") # 1-many","title":"models"},{"location":"lab/#customer-handler-other-are-similar","text":"from typing import List from fastapi import APIRouter, Depends from db import get_session from models import Customer, CustomerCategory customerRouter = APIRouter(prefix=\"/customers\", tags=[\"customer\"]) # \u043e\u0442\u0432\u0435\u0447\u0430\u0435\u0442 \u0437\u0430 swagger @customerRouter.get(\"/\", response_model=list[CustomerCategory]) async def get_customers(session=Depends(get_session)) -> List[Customer]: customers = session.query(Customer).all() return customers @customerRouter.get(\"/{username_id}\", response_model=CustomerCategory) async def get_customer(username_id: int, session=Depends(get_session)) -> Customer: customer = session.get(Customer, username_id) return customer @customerRouter.post(\"/\") async def create_customer(customer: Customer, session=Depends(get_session)): customer = Customer.validate(customer) customer.id = None session.add(customer) session.commit() session.refresh(customer) return customer @customerRouter.patch(\"/{username}\") async def update_customer(customer: Customer, username: str, session=Depends(get_session)): customer = Customer.validate(customer) customer_from_db = session.query(Customer).filter(Customer.username == username).first() if customer_from_db is None: return \"No such customer\" customer_data = customer.model_dump(exclude_unset=True) for key, value in customer_data.items(): if value is None: continue setattr(customer_from_db, key, value) session.add(customer_from_db) session.commit() session.refresh(customer_from_db) return customer_from_db @customerRouter.delete(\"/{username}\") async def delete_customer(username: str, session=Depends(get_session)): session.query(Customer).filter(Customer.username == username).delete() session.commit() return \"Deleted\"","title":"Customer handler (other are similar)"},{"location":"lab/#db","text":"from sqlmodel import SQLModel, Session, create_engine from dotenv import load_dotenv import os load_dotenv('.env') db_url = os.getenv('DB_URL') print(db_url) engine = create_engine(db_url, echo=True) def init_db(): SQLModel.metadata.create_all(engine) def get_session(): with Session(engine) as session: yield session","title":"DB"},{"location":"lab/#screenshots","text":"","title":"Screenshots"},{"location":"lab/#swagger","text":"","title":"Swagger"},{"location":"leetcode/","text":"Leetcode 24.03.2024 - 07.05.2024 = 6 weeks 3sum class Solution: def threeSum(self, nums: List[int]) -> List[List[int]]: res = set() n, p, z = [], [], [] for num in nums: if num > 0: p.append(num) elif num < 0: n.append(num) else: z.append(num) N, P = set(n), set(p) if z: for num in P: if -1*num in N: res.add((-1*num, 0, num)) if len(z) >= 3: res.add((0,0,0)) for i in range(len(n)): for j in range(i+1,len(n)): target = -1*(n[i]+n[j]) if target in P: res.add(tuple(sorted([n[i],n[j],target]))) for i in range(len(p)): for j in range(i+1,len(p)): target = -1*(p[i]+p[j]) if target in N: res.add(tuple(sorted([p[i],p[j],target]))) return res Group Anagrams class Solution: def groupAnagrams(self, strs: List[str]) -> List[List[str]]: result = [] sorted_s = {} i = 0 for s in strs: if not result: sorted_s[''.join(sorted(s))] = i i += 1 result.append([s]) continue for j in range(len(result)): if (''.join(sorted(s))) in sorted_s: result[sorted_s[''.join(sorted(s))]].append(s) break else: sorted_s[''.join(sorted(s))] = i i += 1 result.append([s]) break return result Longest Substring Without Repeating Characters class Solution: def lengthOfLongestSubstring(self, s: str) -> int: n = len(s) maxLength = 0 charIndex = [-1] * 128 left = 0 for right in range(n): if charIndex[ord(s[right])] >= left: left = charIndex[ord(s[right])] + 1 charIndex[ord(s[right])] = right maxLength = max(maxLength, right - left + 1) return maxLength Longest Palindromic Substring class Solution: def longestPalindrome(self, s: str) -> str: if not s: return \"\" def expand_around_center(s: str, left: int, right: int): while left >= 0 and right < len(s) and s[left] == s[right]: left -= 1 right += 1 return right - left - 1 start = 0 end = 0 for i in range(len(s)): odd = expand_around_center(s, i, i) even = expand_around_center(s, i, i + 1) max_len = max(odd, even) if max_len > end - start: start = i - (max_len - 1) // 2 end = i + max_len // 2 return s[start:end+1] Increasing Triplet Subsequence class Solution: def increasingTriplet(self, nums: List[int]) -> bool: first = second = float('inf') for n in nums: if n <= first: first = n elif n <= second: second = n else: return True return False Set Matrix Zeroes class Solution: def setZeroes(self, matrix: List[List[int]]) -> None: m = len(matrix) n = len(matrix[0]) shouldFillFirstRow = 0 in matrix[0] shouldFillFirstCol = 0 in list(zip(*matrix))[0] for i in range(1, m): for j in range(1, n): if matrix[i][j] == 0: matrix[i][0] = 0 matrix[0][j] = 0 for i in range(1, m): for j in range(1, n): if matrix[i][0] == 0 or matrix[0][j] == 0: matrix[i][j] = 0 if shouldFillFirstRow: matrix[0] = [0] * n if shouldFillFirstCol: for row in matrix: row[0] = 0","title":"Leetcode"},{"location":"leetcode/#leetcode","text":"24.03.2024 - 07.05.2024 = 6 weeks","title":"Leetcode"},{"location":"leetcode/#3sum","text":"class Solution: def threeSum(self, nums: List[int]) -> List[List[int]]: res = set() n, p, z = [], [], [] for num in nums: if num > 0: p.append(num) elif num < 0: n.append(num) else: z.append(num) N, P = set(n), set(p) if z: for num in P: if -1*num in N: res.add((-1*num, 0, num)) if len(z) >= 3: res.add((0,0,0)) for i in range(len(n)): for j in range(i+1,len(n)): target = -1*(n[i]+n[j]) if target in P: res.add(tuple(sorted([n[i],n[j],target]))) for i in range(len(p)): for j in range(i+1,len(p)): target = -1*(p[i]+p[j]) if target in N: res.add(tuple(sorted([p[i],p[j],target]))) return res","title":"3sum"},{"location":"leetcode/#group-anagrams","text":"class Solution: def groupAnagrams(self, strs: List[str]) -> List[List[str]]: result = [] sorted_s = {} i = 0 for s in strs: if not result: sorted_s[''.join(sorted(s))] = i i += 1 result.append([s]) continue for j in range(len(result)): if (''.join(sorted(s))) in sorted_s: result[sorted_s[''.join(sorted(s))]].append(s) break else: sorted_s[''.join(sorted(s))] = i i += 1 result.append([s]) break return result","title":"Group Anagrams"},{"location":"leetcode/#longest-substring-without-repeating-characters","text":"class Solution: def lengthOfLongestSubstring(self, s: str) -> int: n = len(s) maxLength = 0 charIndex = [-1] * 128 left = 0 for right in range(n): if charIndex[ord(s[right])] >= left: left = charIndex[ord(s[right])] + 1 charIndex[ord(s[right])] = right maxLength = max(maxLength, right - left + 1) return maxLength","title":"Longest Substring Without Repeating Characters"},{"location":"leetcode/#longest-palindromic-substring","text":"class Solution: def longestPalindrome(self, s: str) -> str: if not s: return \"\" def expand_around_center(s: str, left: int, right: int): while left >= 0 and right < len(s) and s[left] == s[right]: left -= 1 right += 1 return right - left - 1 start = 0 end = 0 for i in range(len(s)): odd = expand_around_center(s, i, i) even = expand_around_center(s, i, i + 1) max_len = max(odd, even) if max_len > end - start: start = i - (max_len - 1) // 2 end = i + max_len // 2 return s[start:end+1]","title":"Longest Palindromic Substring"},{"location":"leetcode/#increasing-triplet-subsequence","text":"class Solution: def increasingTriplet(self, nums: List[int]) -> bool: first = second = float('inf') for n in nums: if n <= first: first = n elif n <= second: second = n else: return True return False","title":"Increasing Triplet Subsequence"},{"location":"leetcode/#set-matrix-zeroes","text":"class Solution: def setZeroes(self, matrix: List[List[int]]) -> None: m = len(matrix) n = len(matrix[0]) shouldFillFirstRow = 0 in matrix[0] shouldFillFirstCol = 0 in list(zip(*matrix))[0] for i in range(1, m): for j in range(1, n): if matrix[i][j] == 0: matrix[i][0] = 0 matrix[0][j] = 0 for i in range(1, m): for j in range(1, n): if matrix[i][0] == 0 or matrix[0][j] == 0: matrix[i][j] = 0 if shouldFillFirstRow: matrix[0] = [0] * n if shouldFillFirstCol: for row in matrix: row[0] = 0","title":"Set Matrix Zeroes"}]}